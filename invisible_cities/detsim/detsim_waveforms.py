import os
import numpy as np

from typing          import Callable
from scipy.integrate import quad

from . light_tables import create_lighttable_function

from . simulate_s1 import compute_scintillation_photons
from . simulate_s1 import compute_s1_pes_at_pmts
from . simulate_s1 import s1_times_pdf

from ..core.system_of_units import mus

def generate_s1_waveform(pes_at_pmts, hit_times, buffer_length, bin_width, start_time):
    """
    Creates the s1-waveform based on the pdf at :s1_times_pdf:

    Parameters:
        :s1_pes_at_pmts: np.ndarray
            the pes at each PMT generated by each hit
        :hit_times: np.ndarray
            emission time of each hit
        :buffer_length: float
            waveform buffer_length, waveform will range from tmin to
            tmin + buffer_length
        :bin_width:
            waveform bin width
        :tmin: float
            waveform start time
    Returns:
        :wfs: list[np.ndarray,..]
            waveform with the S1 signal
    """
    bins = np.arange(start_time, start_time + buffer_length + bin_width, bin_width)
    wfs_ = np.stack([np.histogram(hit_times, bins=bins, weights=pes)[0] for pes in pes_at_pmts])

    # apply s1-time distribution
    wfs = np.zeros(wfs_.shape)
    ## discrete normalization (integrate only up to 2 mus to fasten up)
    ts = np.arange(0, min(2. * mus, buffer_length) + bin_width, bin_width)
    p  = np.zeros(int(buffer_length/bin_width)+1)
    for i, (t0, t1) in enumerate(zip(ts[:-1], ts[1:])): p[i] = quad(s1_times_pdf, t0, t1)[0]
    ## apply over positive counts
    for pmt, wf in enumerate(wfs_):
        idxs = np.argwhere(wf>0).flatten()
        for idx in idxs:
            wfs[pmt, idx:] += (wf[idx] * p[:-idx-1])
    return wfs


def s1_waveforms_creator(s1_lighttable   : str,
                         ws              : float,
                         wf_pmt_bin_width: float)->Callable:
    """
    Returns a function that creates the S1 waveforms from the hits (x, y, z, time, energy),
    with waveform parameters tmin (start absolute time of the waveform) and buffer_length.
    Parameters:
        :s1_lighttable: str
            the s1 lighttable filename, it can contain env variables
        :ws:
            the inverse scintillation yield
        :wf_pmt_bin_width:
            the waveform bin width that is returned by :create_s1_waveforms_from_hits:
    Returns:
        :create_s1_waveforms_from_hits: function
            see function docstring
    """
    s1_lt = create_lighttable_function(os.path.expandvars(s1_lighttable))

    def create_s1_waveforms_from_hits(x, y, z, time, energy, tmin, buffer_length):
        """
        Computes the s1 waveform from hits
        Parameters:
            :x, y, z, time, energy: np.ndarray
                event track hits
            :tmin: float
                waveform start time
            :buffer_length: float
                waveform buffer_length, waveform will range from tmin to
                tmin + buffer_length
        """
        s1_photons     = compute_scintillation_photons(energy, ws)
        s1_pes_at_pmts = compute_s1_pes_at_pmts(x, y, z, s1_photons, s1_lt)
        s1_wfs = generate_s1_waveform(s1_pes_at_pmts, time, buffer_length, wf_pmt_bin_width, tmin)
        return np.random.poisson(s1_wfs)

    return create_s1_waveforms_from_hits
